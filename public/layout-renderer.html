<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Layout View</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Hiragino Sans', 'Noto Sans CJK JP', sans-serif;
            background: #f5f5f5;
            overflow: hidden;
        }
        
        #layout-container {
            position: relative;
            margin: 0 auto;
            background: white;
        }
        
        .layout-component {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            flex-direction: column;
            transition: all 0.3s ease;
            overflow: hidden;
            box-sizing: border-box;
            padding: 10px;
        }
        
        .component-text {
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .component-datapoint {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        .component-image {
            padding: 0 !important;
            display: block !important;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }
        
        .datapoint-value.updating {
            animation: pulse 0.3s ease;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #666;
        }
        
        .error-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #fee;
            color: #c00;
            padding: 20px 40px;
            border-radius: 8px;
            border: 2px solid #c00;
        }
        
        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            background: #10b981;
            color: white;
            z-index: 1000;
        }
        
        .connection-status.disconnected {
            background: #ef4444;
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loading">Loading layout...</div>
    <div class="connection-status" id="connection-status">‚óè Connected</div>
    <div id="layout-container"></div>

    <script>
        const API_BASE = window.location.origin;
        let socket = null;
        let layout = null;
        let datapointMap = {}; // Map datapoint IDs to component elements
        
        // Get layout ID from URL
        const pathParts = window.location.pathname.split('/');
        const layoutId = pathParts[pathParts.length - 1];
        
        async function loadLayout() {
            console.log('üîÑ Loading layout with ID:', layoutId);
            try {
                const response = await fetch(`${API_BASE}/api/layout/${layoutId}`);
                const data = await response.json();
                
                console.log('üì• Layout data received:', data);
                
                if (!data.success) {
                    showError(data.error || 'Layout not found');
                    return;
                }
                
                layout = data.layout;
                console.log('‚úÖ Layout loaded:', {
                    layoutId: layout.layoutId,
                    layoutName: layout.layoutName,
                    raspberryId: layout.raspberryId,
                    componentCount: layout.components.length
                });
                
                document.title = layout.layoutName;
                renderLayout();
                connectWebSocket();
                
            } catch (error) {
                console.error('‚ùå Error loading layout:', error);
                showError('Failed to load layout');
            }
        }
        
        function renderLayout() {
            console.log('üé® Rendering layout:', layout);
            const container = document.getElementById('layout-container');
            container.style.width = layout.canvasWidth + 'px';
            container.style.height = layout.canvasHeight + 'px';
            
            // Apply canvas background
            if (layout.backgroundColor) {
                container.style.backgroundColor = layout.backgroundColor;
            }
            if (layout.backgroundImage) {
                container.style.backgroundImage = `url('${layout.backgroundImage}')`;
                
                // Apply fit mode
                const fitMode = layout.backgroundImageFit || 'cover';
                switch(fitMode) {
                    case 'cover':
                        container.style.backgroundSize = 'cover';
                        container.style.backgroundPosition = 'center';
                        container.style.backgroundRepeat = 'no-repeat';
                        break;
                    case 'contain':
                        container.style.backgroundSize = 'contain';
                        container.style.backgroundPosition = 'center';
                        container.style.backgroundRepeat = 'no-repeat';
                        break;
                    case 'fill':
                        container.style.backgroundSize = '100% 100%';
                        container.style.backgroundPosition = 'center';
                        container.style.backgroundRepeat = 'no-repeat';
                        break;
                    case 'none center':
                        container.style.backgroundSize = 'auto';
                        container.style.backgroundPosition = 'center';
                        container.style.backgroundRepeat = 'no-repeat';
                        break;
                    case 'auto':
                        container.style.backgroundSize = 'auto';
                        container.style.backgroundPosition = 'top left';
                        container.style.backgroundRepeat = 'repeat';
                        break;
                    default:
                        container.style.backgroundSize = 'cover';
                        container.style.backgroundPosition = 'center';
                        container.style.backgroundRepeat = 'no-repeat';
                }
            }
            
            // Center container on screen
            container.style.position = 'absolute';
            container.style.top = '50%';
            container.style.left = '50%';
            container.style.transform = 'translate(-50%, -50%)';
            
            // Render components
            console.log(`üì¶ Rendering ${layout.components.length} components...`);
            layout.components.forEach(comp => {
                const el = createComponentElement(comp);
                container.appendChild(el);
                
                // Track datapoint components
                if (comp.type === 'datapoint' && comp.datapointId) {
                    console.log(`üìç Tracking datapoint: ${comp.datapointId} (${comp.label})`);
                    datapointMap[comp.datapointId] = el;
                }
            });
            
            console.log('‚úÖ Layout rendered. DatapointMap:', datapointMap);
            document.getElementById('loading').style.display = 'none';
        }
        
        function createComponentElement(comp) {
            const el = document.createElement('div');
            el.className = 'layout-component component-' + comp.type;
            el.style.left = comp.x + 'px';
            el.style.top = comp.y + 'px';
            el.style.width = comp.width + 'px';
            el.style.height = comp.height + 'px';
            el.style.zIndex = comp.zIndex || 0;
            
            if (comp.styles) {
                if (comp.styles.fontSize) el.style.fontSize = comp.styles.fontSize + 'px';
                if (comp.styles.color) el.style.color = comp.styles.color;
                if (comp.styles.backgroundColor) el.style.backgroundColor = comp.styles.backgroundColor;
                if (comp.styles.fontWeight) el.style.fontWeight = comp.styles.fontWeight;
                if (comp.styles.textAlign) el.style.textAlign = comp.styles.textAlign;
                if (comp.styles.whiteSpace) el.style.whiteSpace = comp.styles.whiteSpace;
                if (comp.styles.overflow) el.style.overflow = comp.styles.overflow;
                if (comp.styles.lineHeight) el.style.lineHeight = comp.styles.lineHeight;
            }
            
            if (comp.type === 'text') {
                el.classList.add('component-text');
                el.textContent = comp.content || '';
            } else if (comp.type === 'datapoint') {
                el.classList.add('component-datapoint');
                const baseFontSize = comp.styles?.fontSize || 16;
                el.innerHTML = `
                    <div class="datapoint-label" style="font-size: ${baseFontSize * 0.7}px; opacity: 0.7;">${comp.label || 'Label'}</div>
                    <div class="datapoint-value" data-datapoint-id="${comp.datapointId}" style="font-size: ${baseFontSize}px; font-weight: bold;">---</div>
                    <div class="datapoint-unit" style="font-size: ${baseFontSize * 0.6}px; opacity: 0.5;">${comp.unit || ''}</div>
                `;
            } else if (comp.type === 'image') {
                el.classList.add('component-image');
                el.style.backgroundImage = `url('${comp.imageUrl}')`;
                el.style.backgroundSize = comp.styles?.objectFit || 'contain';
                el.style.backgroundPosition = 'center';
                el.style.backgroundRepeat = 'no-repeat';
                el.style.opacity = (comp.styles?.opacity || 100) / 100;
            }
            
            return el;
        }
        
        function connectWebSocket() {
            console.log('üîå Connecting to WebSocket at:', API_BASE);
            socket = io(API_BASE, {
                transports: ['websocket', 'polling']
            });
            
            socket.on('connect', () => {
                console.log('‚úÖ WebSocket connected with ID:', socket.id);
                updateConnectionStatus(true);
                
                // Register as monitor
                const registrationData = {
                    raspberryId: layout.raspberryId,
                    layoutId: layout.layoutId
                };
                console.log('üì± Registering as monitor:', registrationData);
                socket.emit('monitor_register', registrationData);
            });
            
            socket.on('disconnect', () => {
                console.log('‚ùå WebSocket disconnected');
                updateConnectionStatus(false);
            });
            
            socket.on('opcua_realtime_update', (data) => {
                console.log('üì° Received opcua_realtime_update event');
                updateDatapoints(data);
            });
            
            socket.on('raspberry_status_update', (data) => {
                console.log('üì± Raspberry status:', data);
                // Could show indicator if Raspberry Pi is offline
            });
            
            // Debug: Log all incoming events
            socket.onAny((eventName, ...args) => {
                console.log(`üîî Socket event received: ${eventName}`, args);
            });
        }
        
        function updateDatapoints(data) {
            console.log('üìä Received opcua_realtime_update:', data);
            
            if (!data || !data.data || !Array.isArray(data.data)) {
                console.warn('‚ö†Ô∏è Invalid data format:', data);
                return;
            }
            
            console.log(`üìà Updating ${data.data.length} datapoints...`);
            console.log('üó∫Ô∏è Current datapointMap:', datapointMap);
            
            data.data.forEach(dp => {
                console.log(`üîç Looking for datapointId: ${dp.datapointId}, value: ${dp.value}`);
                const el = datapointMap[dp.datapointId];
                
                if (el) {
                    console.log(`‚úÖ Found element for ${dp.datapointId}`);
                    const valueEl = el.querySelector('.datapoint-value');
                    if (valueEl) {
                        const newValue = dp.value !== null && dp.value !== undefined ? dp.value : '---';
                        console.log(`‚úÖ Updating value from "${valueEl.textContent}" to "${newValue}"`);
                        console.log(`   Raw value: ${dp.value}, Type: ${typeof dp.value}`);
                        valueEl.textContent = newValue;
                        console.log(`   DOM updated. Current textContent: "${valueEl.textContent}"`);
                        valueEl.classList.add('updating');
                        setTimeout(() => valueEl.classList.remove('updating'), 300);
                    } else {
                        console.warn(`‚ö†Ô∏è No .datapoint-value element found in component`);
                    }
                } else {
                    console.warn(`‚ö†Ô∏è No element found in datapointMap for datapointId: ${dp.datapointId}`);
                }
            });
        }
        
        function updateConnectionStatus(connected) {
            const status = document.getElementById('connection-status');
            if (connected) {
                status.textContent = '‚óè Connected';
                status.classList.remove('disconnected');
            } else {
                status.textContent = '‚óè Disconnected';
                status.classList.add('disconnected');
            }
        }
        
        function showError(message) {
            document.getElementById('loading').style.display = 'none';
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = message;
            document.body.appendChild(errorDiv);
        }
        
        // Load layout on page load
        loadLayout();
    </script>
</body>
</html>
